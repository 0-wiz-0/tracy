#ifndef __TRACYMETAL_HMM__
#define __TRACYMETAL_HMM__

#ifndef TRACY_ENABLE

#define TracyMetalContext(device) nullptr
#define TracyMetalDestroy(ctx)
#define TracyMetalContextName(ctx, name, size)

#define TracyMetalZone(ctx, name)
#define TracyMetalZoneC(ctx, name, color)
#define TracyMetalNamedZone(ctx, varname, name, active)
#define TracyMetalNamedZoneC(ctx, varname, name, color, active)
#define TracyMetalZoneTransient(ctx, varname, name, active)

#define TracyMetalZoneS(ctx, name, depth)
#define TracyMetalZoneCS(ctx, name, color, depth)
#define TracyMetalNamedZoneS(ctx, varname, name, depth, active)
#define TracyMetalNamedZoneCS(ctx, varname, name, color, depth, active)
#define TracyMetalZoneTransientS(ctx, varname, name, depth, active)

#define TracyMetalCollect(ctx)

namespace tracy
{
class MetalZoneScope {};
}

using TracyMetalCtx = void*;

#else

#include <atomic>
#include <assert.h>
#include <stdlib.h>

#include "Tracy.hpp"
#include "../client/TracyProfiler.hpp"
#include "../client/TracyCallstack.hpp"
#include "../common/TracyAlign.hpp"
#include "../common/TracyAlloc.hpp"

// ok to import if in obj-c code
#import <Metal/Metal.h>

#define TRACY_METAL_DEBUG_NO_WRAPAROUND (0)

#define VA_ARGS(...) , ##__VA_ARGS__

#define TracyMetalPanic(ret, msg, ...) do { \
    char buffer [1024]; \
    snprintf(buffer, sizeof(buffer), "TracyMetal: " msg VA_ARGS(__VA_ARGS__)); \
    TracyMessageC(buffer, strlen(buffer), tracy::Color::OrangeRed); \
    fprintf(stderr, "%s\n", buffer); \
    assert(false && "TracyMetal: " msg); \
    ret; \
    } while(false);


namespace tracy
{

class MetalCtx
{
    friend class MetalZoneScope;

    enum { MaxQueries = 4 * 1024 };    // Metal: between 8 and 32768 _BYTES_...

public:
    MetalCtx(id<MTLDevice> device)
        : m_device(device)
    {
        ZoneScopedNC("TracyMetalCtx", tracy::Color::Red4);
        
        TracyMetalPanic(, "MTLCounterErrorValue = 0x%llx", MTLCounterErrorValue);
        TracyMetalPanic(, "MTLCounterDontSample = 0x%llx", MTLCounterDontSample);
        
        if (m_device == nil)
        {
            TracyMetalPanic(return, "device is nil.");
        }
        if (![m_device supportsCounterSampling:MTLCounterSamplingPointAtStageBoundary])
        {
            TracyMetalPanic(return, "ERROR: timestamp sampling at pipeline stage boundary is not supported.");
        }
        if (![m_device supportsCounterSampling:MTLCounterSamplingPointAtDrawBoundary])
        {
            TracyMetalPanic(, "WARNING: timestamp sampling at draw call boundary is not supported.");
        }
        if (![m_device supportsCounterSampling:MTLCounterSamplingPointAtBlitBoundary])
        {
            TracyMetalPanic(, "WARNING: timestamp sampling at blit boundary is not supported.");
        }
        if (![m_device supportsCounterSampling:MTLCounterSamplingPointAtDispatchBoundary])
        {
            TracyMetalPanic(, "WARNING: timestamp sampling at compute dispatch boundary is not supported.");
        }
        if (![m_device supportsCounterSampling:MTLCounterSamplingPointAtTileDispatchBoundary])
        {
            TracyMetalPanic(, "WARNING: timestamp sampling at tile dispatch boundary is not supported.");
        }
        id<MTLCounterSet> timestampCounterSet = nil;
        for (id<MTLCounterSet> counterSet in m_device.counterSets)
        {
            if ([counterSet.name isEqualToString:MTLCommonCounterSetTimestamp])
            {
                timestampCounterSet = counterSet;
                break;
            }
        }
        if (timestampCounterSet == nil)
        {
            TracyMetalPanic(return, "ERROR: timestamp counters are not supported on the platform.");
        }
        
        MTLCounterSampleBufferDescriptor* sampleDescriptor = [[MTLCounterSampleBufferDescriptor alloc] init];
        sampleDescriptor.counterSet = timestampCounterSet;
        sampleDescriptor.sampleCount = MaxQueries;
        sampleDescriptor.storageMode = MTLStorageModeShared;
        sampleDescriptor.label = @"TracyMetalTimestampPool";
        
        NSError* error = nil;
        id<MTLCounterSampleBuffer> counterSampleBuffer = [m_device newCounterSampleBufferWithDescriptor:sampleDescriptor error:&error];
        if (error != nil)
        {
            NSLog(@"%@", error.localizedDescription);
            NSLog(@"%@", error.localizedFailureReason);
            TracyMetalPanic(return, "ERROR: unable to create sample buffer for timestamp counters.");
        }
        m_counterSampleBuffer = counterSampleBuffer;
        
        m_timestampRequestTime.resize(MaxQueries);
        go_horse.resize(MaxQueries);

        MTLTimestamp cpuTimestamp = 0;
        MTLTimestamp gpuTimestamp = 0;
        [m_device sampleTimestamps:&cpuTimestamp gpuTimestamp:&gpuTimestamp];
        TracyMetalPanic(, "Calibration: CPU timestamp (Metal): %llu", cpuTimestamp);
        TracyMetalPanic(, "Calibration: GPU timestamp (Metal): %llu", gpuTimestamp);
        cpuTimestamp = Profiler::GetTime();
        TracyMetalPanic(, "Calibration: CPU timestamp (Tracy): %llu", cpuTimestamp);
        float period = 1.0f;
        
        m_contextId = GetGpuCtxCounter().fetch_add(1);
        
        auto* item = Profiler::QueueSerial();
        MemWrite(&item->hdr.type, QueueType::GpuNewContext);
        MemWrite(&item->gpuNewContext.cpuTime, int64_t(cpuTimestamp));
        MemWrite(&item->gpuNewContext.gpuTime, int64_t(gpuTimestamp));
        MemWrite(&item->gpuNewContext.thread, uint32_t(0)); // #TODO: why not GetThreadHandle()?
        MemWrite(&item->gpuNewContext.period, period);
        MemWrite(&item->gpuNewContext.context, m_contextId);
        //MemWrite(&item->gpuNewContext.flags, GpuContextCalibration);
        MemWrite(&item->gpuNewContext.flags, GpuContextFlags(0));
        MemWrite(&item->gpuNewContext.type, GpuContextType::Metal);
        Profiler::QueueSerialFinish();  // TODO: DeferItem() for TRACY_ON_DEMAND
    }

    ~MetalCtx()
    {
        ZoneScopedNC("~TracyMetalCtx", tracy::Color::Red4);
    }

    static MetalCtx* Create(id<MTLDevice> device)
    {
        auto ctx = static_cast<MetalCtx*>(tracy_malloc(sizeof(MetalCtx)));
        new (ctx) MetalCtx(device);
        if (ctx->m_contextId == 255)
        {
            Destroy(ctx);
            TracyMetalPanic(return nullptr, "ERROR: unable to create context.");
        }
        return ctx;
    }

    static void Destroy(MetalCtx* ctx)
    {
        ctx->~MetalCtx();
        tracy_free(ctx);
    }

    void Name( const char* name, uint16_t len )
    {
        auto ptr = (char*)tracy_malloc( len );
        memcpy( ptr, name, len );

        auto item = Profiler::QueueSerial();
        MemWrite( &item->hdr.type, QueueType::GpuContextName );
        MemWrite( &item->gpuContextNameFat.context, m_contextId );
        MemWrite( &item->gpuContextNameFat.ptr, (uint64_t)ptr );
        MemWrite( &item->gpuContextNameFat.size, len );
#ifdef TRACY_ON_DEMAND
        GetProfiler().DeferItem( *item );
#endif
        Profiler::QueueSerialFinish();
    }

    bool Collect()
    {
        ZoneScopedNC("TracyMetal::Collect", Color::Red4);

#ifdef TRACY_ON_DEMAND
        if (!GetProfiler().IsConnected())
        {
            return true;
        }
#endif

        // Only one thread is allowed to collect timestamps at any given time
        // but there's no need to block contending threads
        if (!m_collectionMutex.try_lock())
        {
            return true;
        }

        std::unique_lock lock (m_collectionMutex, std::adopt_lock);

        uintptr_t begin = m_previousCheckpoint.load();
        uintptr_t latestCheckpoint = m_queryCounter.load(); // TODO: MTLEvent? MTLFence?;
#if TRACY_METAL_DEBUG_NO_WRAPAROUND
        latestCheckpoint = (latestCheckpoint >= MaxQueries) ? MaxQueries : latestCheckpoint;
        //if (latestCheckpoint >= MaxQueries) return true;
#endif
        uint32_t count = RingCount(begin, latestCheckpoint);
        ZoneValue(begin);
        ZoneValue(latestCheckpoint);

        if (count == 0)   // no pending timestamp queries
        {
            //uintptr_t nextCheckpoint = m_queryCounter.load();
            //if (nextCheckpoint != latestCheckpoint)
            //{
            //    // TODO: signal event / fence now?
            //}
            return true;
        }

        if (RingIndex(begin) + count > RingSize())
        {
            count = RingSize() - RingIndex(begin);
        }
        ZoneValue(count);

        if (count >= MaxQueries)
        {
            TracyMetalPanic(return false, "Collect: FULL! too many pending timestamp queries. [%llu, %llu] (%u)", begin, latestCheckpoint, count);
        }

        //TracyMetalPanic(, "Collect: [%llu, %llu] :: (%u)", begin, latestCheckpoint, count);

        NSRange range = NSMakeRange(RingIndex(begin), count);
        NSData* data = [m_counterSampleBuffer resolveCounterRange:range];
        NSUInteger numResolvedTimestamps = data.length / sizeof(MTLCounterResultTimestamp);
        MTLCounterResultTimestamp* timestamps = (MTLCounterResultTimestamp *)(data.bytes);
        if (timestamps == nil)
        {
            TracyMetalPanic(return false, "Collect: unable to resolve timestamps.");
        }

        if (numResolvedTimestamps != count)
        {
            TracyMetalPanic(, "Collect: numResolvedTimestamps != count : %u != %u", (uint32_t)numResolvedTimestamps, count);
        }

        for (auto i = 0; i < numResolvedTimestamps; i += 2)
        {
            static MTLTimestamp lastValidTimestamp = 0;
            MTLTimestamp& t_start = timestamps[i+0].timestamp;
            MTLTimestamp& t_end = timestamps[i+1].timestamp;
            uint32_t k = RingIndex(begin + i);
            //fprintf(stdout, "TracyMetal: Collect: timestamp[%u] = %llu | timestamp[%u] = %llu | diff = %llu\n", k, t_start, k+1, t_end, (t_end - t_start));
            if ((t_start == MTLCounterErrorValue)  || (t_end == MTLCounterErrorValue))
            {
                TracyMetalPanic(, "Collect: invalid timestamp (MTLCounterErrorValue) at %u.", k);
                break;
            }
            if (go_horse[k+0] == 0)
            {
                TracyMetalPanic(, "Collect: go_horse not ready at %u (%llu).", k+0, begin+i+0);
                break;
            }
            if (go_horse[k+1] == 0)
            {
                TracyMetalPanic(, "Collect: go_horse not ready at %u (%llu).", k+1, begin+i+1);
                break;
            }
            if ((t_start == 0) || (t_end == 0)) // zero is apparently also considered "invalid"...
            {
                break;
                
                auto checkTime = std::chrono::high_resolution_clock::now();
                auto requestTime = m_timestampRequestTime[k];
                auto ms_in_flight = std::chrono::duration<float>(checkTime-requestTime).count()*1000.0f;
                //TracyMetalPanic(, "Collect: invalid timestamp (zero) at %u [%.0fms in flight].", k, ms_in_flight);
                const float timeout_ms = 2000.0f;
                if (ms_in_flight < timeout_ms)
                    break;
                static int HACK_retries = 0;
                //if (++HACK_retries <= 1000000)
                //    break;
                TracyMetalPanic(, "Collect: giving up on timestamp at %u [%.0fms in flight].", k, ms_in_flight);
                t_start = t_end = lastValidTimestamp + 100;
                HACK_retries = 0;
            }
            auto t_start_copy = t_start;
            auto t_end_copy = t_end;
            t_start = t_end = MTLCounterErrorValue;  // "reset" timestamps
            t_start = t_end = 0;
            m_timestampRequestTime[k+0] += std::chrono::minutes(60);
            m_timestampRequestTime[k+1] += std::chrono::minutes(60);
            go_horse[k+0] = go_horse[k+1] = 0;
            {
            auto* item = Profiler::QueueSerial();
            MemWrite(&item->hdr.type, QueueType::GpuTime);
            MemWrite(&item->gpuTime.gpuTime, static_cast<int64_t>(t_start_copy));
            MemWrite(&item->gpuTime.queryId, static_cast<uint16_t>(k));
            MemWrite(&item->gpuTime.context, m_contextId);
            Profiler::QueueSerialFinish();
            }
            {
            auto* item = Profiler::QueueSerial();
            MemWrite(&item->hdr.type, QueueType::GpuTime);
            MemWrite(&item->gpuTime.gpuTime, static_cast<int64_t>(t_end_copy));
            MemWrite(&item->gpuTime.queryId, static_cast<uint16_t>(k+1));
            MemWrite(&item->gpuTime.context, m_contextId);
            Profiler::QueueSerialFinish();
            }
            TracyMetalPanic(, "zone %u ]", k);
            TracyMetalPanic(, "zone %u ]", k+1);
            lastValidTimestamp = t_end_copy;
            TracyFreeN((void*)(uintptr_t)k, "TracyMetalTimestampQueryId");
            m_previousCheckpoint += 2;
        }
        ZoneValue(RingCount(begin, m_previousCheckpoint.load()));

        //RecalibrateClocks();    // to account for drift

        return true;
    }

private:
    tracy_force_inline uint32_t RingIndex(uintptr_t index)
    {
        index %= MaxQueries;
        return static_cast<uint32_t>(index);
    }

    tracy_force_inline uint32_t RingCount(uintptr_t begin, uintptr_t end)
    {
        // wrap-around safe: all unsigned
        uintptr_t count = end - begin;
        return static_cast<uint32_t>(count);
    }

    tracy_force_inline uint32_t RingSize() const
    {
        return MaxQueries;
    }

    tracy_force_inline unsigned int NextQueryId(int n=1)
    {
        ZoneScopedNC("TracyMetal::NextQueryId", tracy::Color::LightCoral);
        auto id = m_queryCounter.fetch_add(n);
#if TRACY_METAL_DEBUG_NO_WRAPAROUND
        if (id >= MaxQueries) return MaxQueries;
#endif
        ZoneValue(id);
        auto count = RingCount(m_previousCheckpoint, id);
        if (count >= MaxQueries)
        {
            TracyMetalPanic(, "NextQueryId: FULL! too many pending timestamp queries. [%llu, %llu] (%u)", m_previousCheckpoint.load(), id, count);
            // #TODO: return some sentinel value; ideally a "hidden" query index
            return (MaxQueries - n);
        }
        uint32_t idx = RingIndex(id);
        TracyAllocN((void*)(uintptr_t)idx, 2, "TracyMetalTimestampQueryId");
        m_timestampRequestTime[idx] = std::chrono::high_resolution_clock::now();
        //if (id >= MaxQueries)
        //    TracyMetalPanic(, "NextQueryId: %u (%llu)", idx, id);
        return idx;
    }

    tracy_force_inline uint8_t GetContextId() const
    {
        return m_contextId;
    }

    uint8_t m_contextId = 255;

    id<MTLDevice> m_device = nil;
    id<MTLCounterSampleBuffer> m_counterSampleBuffer = nil;
    
    using atomic_counter = std::atomic<uintptr_t>;
    static_assert(atomic_counter::is_always_lock_free);
    atomic_counter m_queryCounter = 0;

    atomic_counter m_previousCheckpoint = 0;
    atomic_counter::value_type m_nextCheckpoint = 0;
    
    std::vector<std::chrono::high_resolution_clock::time_point> m_timestampRequestTime;
    std::vector<uint64_t> go_horse;
    
    std::mutex m_collectionMutex;
};

class MetalZoneScope
{
public:
    tracy_force_inline MetalZoneScope( MetalCtx* ctx, MTLComputePassDescriptor* desc, const SourceLocationData* srcloc, bool is_active )
#ifdef TRACY_ON_DEMAND
        : m_active( is_active && GetProfiler().IsConnected() )
#else
        : m_active( is_active )
#endif
    {
        if ( !m_active ) return;
        if (desc == nil) TracyMetalPanic(return, "pass descriptor is nil.");
        m_ctx = ctx;

        auto queryId = m_queryId = ctx->NextQueryId(2);
#if TRACY_METAL_DEBUG_NO_WRAPAROUND
        if (queryId >= MetalCtx::MaxQueries) return;
#endif

        desc.sampleBufferAttachments[0].sampleBuffer = ctx->m_counterSampleBuffer;
        desc.sampleBufferAttachments[0].startOfEncoderSampleIndex = queryId;
        desc.sampleBufferAttachments[0].endOfEncoderSampleIndex = queryId+1;

        SubmitZoneBeginGpu(ctx, queryId, srcloc);
        //SubmitZoneEndGpu(ctx, queryId+1);
    }

    tracy_force_inline MetalZoneScope( MetalCtx* ctx, MTLBlitPassDescriptor* desc, const SourceLocationData* srcloc, bool is_active )
#ifdef TRACY_ON_DEMAND
        : m_active( is_active && GetProfiler().IsConnected() )
#else
        : m_active( is_active )
#endif
    {
        if ( !m_active ) return;
        if (desc == nil) TracyMetalPanic(return, "pass descriptor is nil.");
        m_ctx = ctx;

        auto queryId = m_queryId = ctx->NextQueryId(2);
#if TRACY_METAL_DEBUG_NO_WRAPAROUND
        if (queryId >= MetalCtx::MaxQueries) return;
#endif

        desc.sampleBufferAttachments[0].sampleBuffer = ctx->m_counterSampleBuffer;
        desc.sampleBufferAttachments[0].startOfEncoderSampleIndex = queryId;
        desc.sampleBufferAttachments[0].endOfEncoderSampleIndex = queryId+1;

        SubmitZoneBeginGpu(ctx, queryId, srcloc);
        //SubmitZoneEndGpu(ctx, queryId+1);
    }

    tracy_force_inline MetalZoneScope( MetalCtx* ctx, MTLRenderPassDescriptor* desc, const SourceLocationData* srcloc, bool is_active )
#ifdef TRACY_ON_DEMAND
        : m_active( is_active && GetProfiler().IsConnected() )
#else
        : m_active( is_active )
#endif
    {
        if ( !m_active ) return;
        if (desc == nil) TracyMetalPanic(return, "pass descriptor is nil.");
        m_ctx = ctx;

        auto queryId = m_queryId = ctx->NextQueryId(2);
#if TRACY_METAL_DEBUG_NO_WRAPAROUND
        if (queryId >= MetalCtx::MaxQueries) return;
#endif

        desc.sampleBufferAttachments[0].sampleBuffer = ctx->m_counterSampleBuffer;
        desc.sampleBufferAttachments[0].startOfVertexSampleIndex = queryId;
        desc.sampleBufferAttachments[0].endOfVertexSampleIndex = MTLCounterDontSample;
        desc.sampleBufferAttachments[0].startOfFragmentSampleIndex = MTLCounterDontSample;
        desc.sampleBufferAttachments[0].endOfFragmentSampleIndex = queryId+1;

        SubmitZoneBeginGpu(ctx, queryId, srcloc);
        //SubmitZoneEndGpu(ctx, queryId+1);
    }

#if 0
    tracy_force_inline MetalZoneScope( MetalCtx* ctx, id<MTLComputeCommandEncoder> cmdEncoder, const SourceLocationData* srcloc, bool is_active )
#ifdef TRACY_ON_DEMAND
        : m_active( is_active && GetProfiler().IsConnected() )
#else
        : m_active( is_active )
#endif
    {
        if( !m_active ) return;
        m_ctx = ctx;
        m_cmdEncoder = cmdEncoder;

        auto queryId = m_queryId = ctx->NextQueryId();
#if TRACY_METAL_DEBUG_NO_WRAPAROUND
        if (queryId >= MetalCtx::MaxQueries) return;
#endif

        [m_cmdEncoder sampleCountersInBuffer:m_ctx->m_counterSampleBuffer atSampleIndex:queryId withBarrier:YES];

        SubmitZoneBeginGpu(ctx, queryId, srcloc);
    }
#endif

    tracy_force_inline ~MetalZoneScope()
    {
        if( !m_active ) return;
        
        auto queryId = m_queryId + 1;

#if TRACY_METAL_DEBUG_NO_WRAPAROUND
        if (queryId >= MetalCtx::MaxQueries) return;
#endif
        
        SubmitZoneEndGpu(m_ctx, queryId);
    }

private:
    const bool m_active;

    MetalCtx* m_ctx;
    id<MTLComputeCommandEncoder> m_cmdEncoder;
    
    static void SubmitZoneBeginGpu(MetalCtx* ctx, uint32_t queryId, const SourceLocationData* srcloc)
    {
        auto* item = Profiler::QueueSerial();
        MemWrite( &item->hdr.type, QueueType::GpuZoneBeginSerial );
        MemWrite( &item->gpuZoneBegin.cpuTime, Profiler::GetTime() );
        MemWrite( &item->gpuZoneBegin.srcloc, (uint64_t)srcloc );
        MemWrite( &item->gpuZoneBegin.thread, GetThreadHandle() );
        MemWrite( &item->gpuZoneBegin.queryId, uint16_t( queryId ) );
        MemWrite( &item->gpuZoneBegin.context, ctx->GetContextId() );
        Profiler::QueueSerialFinish();
        
        TracyMetalPanic(, "zone %u [", queryId);
        
        ctx->go_horse[queryId] = 1;
    }
    
    static void SubmitZoneEndGpu(MetalCtx* ctx, uint32_t queryId)
    {
        auto* item = Profiler::QueueSerial();
        MemWrite( &item->hdr.type, QueueType::GpuZoneEndSerial );
        MemWrite( &item->gpuZoneEnd.cpuTime, Profiler::GetTime() );
        MemWrite( &item->gpuZoneEnd.thread, GetThreadHandle() );
        MemWrite( &item->gpuZoneEnd.queryId, uint16_t( queryId ) );
        MemWrite( &item->gpuZoneEnd.context, ctx->GetContextId() );
        Profiler::QueueSerialFinish();
        
        TracyMetalPanic(, "zone %u {]", queryId);
        
        ctx->go_horse[queryId] = 1;
    }

public:
    uint32_t m_queryId = 0;
};

}

using TracyMetalCtx = tracy::MetalCtx*;

#define TracyMetalContext(device) tracy::MetalCtx::Create(device)
#define TracyMetalDestroy(ctx) tracy::MetalCtx::Destroy(ctx)
#define TracyMetalContextName(ctx, name, size) ctx->Name(name, size)

#if defined TRACY_HAS_CALLSTACK && defined TRACY_CALLSTACK
#  define TracyMetalZone( ctx, name ) TracyMetalNamedZoneS( ctx, ___tracy_gpu_zone, name, TRACY_CALLSTACK, true )
#  define TracyMetalZoneC( ctx, name, color ) TracyMetalNamedZoneCS( ctx, ___tracy_gpu_zone, name, color, TRACY_CALLSTACK, true )
#  define TracyMetalNamedZone( ctx, varname, name, active ) static constexpr tracy::SourceLocationData TracyConcat(__tracy_gpu_source_location,TracyLine) { name, TracyFunction,  TracyFile, (uint32_t)TracyLine, 0 }; tracy::MetalZoneScope varname( ctx, &TracyConcat(__tracy_gpu_source_location,TracyLine), TRACY_CALLSTACK, active );
#  define TracyMetalNamedZoneC( ctx, varname, name, color, active ) static constexpr tracy::SourceLocationData TracyConcat(__tracy_gpu_source_location,TracyLine) { name, TracyFunction,  TracyFile, (uint32_t)TracyLine, color }; tracy::MetalZoneScope varname( ctx, &TracyConcat(__tracy_gpu_source_location,TracyLine), TRACY_CALLSTACK, active );
#  define TracyMetalZoneTransient(ctx, varname, name, active) TracyMetalZoneTransientS(ctx, varname, cmdList, name, TRACY_CALLSTACK, active)
#else
#  define TracyMetalZone( ctx, cmdEnc, name ) TracyMetalNamedZone( ctx, ___tracy_gpu_zone, cmdEnc, name, true )
#  define TracyMetalZoneC( ctx, name, color ) TracyMetalNamedZoneC( ctx, ___tracy_gpu_zone, name, color, true )
#  define TracyMetalNamedZone( ctx, varname, cmdEnc, name, active ) static constexpr tracy::SourceLocationData TracyConcat(__tracy_gpu_source_location,TracyLine) { name, TracyFunction,  TracyFile, (uint32_t)TracyLine, 0 }; tracy::MetalZoneScope varname( ctx, cmdEnc, &TracyConcat(__tracy_gpu_source_location,TracyLine), active );
#  define TracyMetalNamedZoneC( ctx, varname, name, color, active ) static constexpr tracy::SourceLocationData TracyConcat(__tracy_gpu_source_location,TracyLine) { name, TracyFunction,  TracyFile, (uint32_t)TracyLine, color }; tracy::MetalZoneScope varname( ctx, &TracyConcat(__tracy_gpu_source_location,TracyLine), active );
#  define TracyMetalZoneTransient(ctx, varname, name, active) tracy::MetalZoneScope varname{ ctx, TracyLine, TracyFile, strlen(TracyFile), TracyFunction, strlen(TracyFunction), name, strlen(name), active };
#endif

#ifdef TRACY_HAS_CALLSTACK
#  define TracyMetalZoneS( ctx, name, depth ) TracyMetalNamedZoneS( ctx, ___tracy_gpu_zone, name, depth, true )
#  define TracyMetalZoneCS( ctx, name, color, depth ) TracyMetalNamedZoneCS( ctx, ___tracy_gpu_zone, name, color, depth, true )
#  define TracyMetalNamedZoneS( ctx, varname, name, depth, active ) static constexpr tracy::SourceLocationData TracyConcat(__tracy_gpu_source_location,TracyLine) { name, TracyFunction,  TracyFile, (uint32_t)TracyLine, 0 }; tracy::MetalZoneScope varname( ctx, &TracyConcat(__tracy_gpu_source_location,TracyLine), depth, active );
#  define TracyMetalNamedZoneCS( ctx, varname, name, color, depth, active ) static constexpr tracy::SourceLocationData TracyConcat(__tracy_gpu_source_location,TracyLine) { name, TracyFunction,  TracyFile, (uint32_t)TracyLine, color }; tracy::MetalZoneScope varname( ctx, &TracyConcat(__tracy_gpu_source_location,TracyLine), depth, active );
#  define TracyMetalZoneTransientS(ctx, varname, name, depth, active) tracy::MetalZoneScope varname{ ctx, TracyLine, TracyFile, strlen(TracyFile), TracyFunction, strlen(TracyFunction), name, strlen(name), depth, active };
#else
#  define TracyMetalZoneS( ctx, name, depth, active ) TracyMetalZone( ctx, name )
#  define TracyMetalZoneCS( ctx, name, color, depth, active ) TracyMetalZoneC( name, color )
#  define TracyMetalNamedZoneS( ctx, varname, name, depth, active ) TracyMetalNamedZone( ctx, varname, name, active )
#  define TracyMetalNamedZoneCS( ctx, varname, name, color, depth, active ) TracyMetalNamedZoneC( ctx, varname, name, color, active )
#  define TracyMetalZoneTransientS(ctx, varname, name, depth, active) TracyMetalZoneTransient(ctx, varname, name, active)
#endif

#define TracyMetalCollect( ctx ) ctx->Collect();

#endif

#endif//__TRACYMETAL_HMM__
